### MOV指令
&emsp;MOV指令的作用是将源操作数复制到目标操作数，类似于java中的赋值操作，在几乎所有的汇编语言指令中所有的操作数都是左边是目标操作数，右边是源操作数。   
&emsp;就像这样：``` MOV AX 001AH ``` 源操作数为001AH，而目标操作数为AX寄存器，旨在将001A这个十六进制数据，赋值或者说是传送到AX寄存器中去，H表示这条数据为十六进制。  

### ADD指令
&emsp;ADD指令的作用就和ADD这个单词意思一样，进行加法操作。不仅可以低位和低位相加，高位和高位相加，还可以高位和低位相加。注意，左边的数是目标操作数，右边的数是源操作数，进行指令操作后结果都会赋值给左边的目标操作源。
<div align="center">
  <img src = "https://github.com/V9n0m/Assembly-language-study-notes/assets/81289456/41415ed7-b073-4fef-bc69-2bea25d581d6" width = 60% />
</div>

### 💦溢出了
先说MOV指令和ADD指令在操作时发生的溢出情况，我们先假设AX和BX中的原始值为8226H和8226H，然后再执行ADD AX BX这个指令，先用计算器计算8226H加8226H，实际上就是8226+8226因为H只是十六进制的一个标志，结果是1044C，但是在程序运行这条指令时的结果却是044C。为什么会这样呢？  
<div align="center">  
  <img src = "https://github.com/V9n0m/Assembly-language-study-notes/assets/81289456/11d8a5c9-124e-4f90-800a-890e688dd606" width = 20% />
</div>

&emsp;其实044C已经够十六位了，而1044C存储在十六位时其中的1超出十六位了，将没有地方保存，所以就溢出了。在进行低位运算时也会产生这种溢出的情况，第一次看到时会有这样的疑问，低位运算超出的部分难道不应该进到高位里去吗？答案是否定的，因为寄存器低位运算溢出时不会影响到高位，多出的部分将会被丢弃。
